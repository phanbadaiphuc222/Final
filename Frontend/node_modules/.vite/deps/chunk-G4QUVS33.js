import {
  Component,
  ErrorFactory,
  FirebaseError,
  Logger,
  __assign,
  __awaiter,
  __generator,
  __read,
  __spreadArray,
  __values,
  areCookiesEnabled,
  calculateBackoffMillis,
  index_esm_default,
  isBrowserExtension,
  isIndexedDBAvailable,
  validateIndexedDBOpenable
} from "./chunk-4GESA4VQ.js";

// node_modules/idb/lib/idb.mjs
function toArray(arr) {
  return Array.prototype.slice.call(arr);
}
function promisifyRequest(request) {
  return new Promise(function(resolve, reject) {
    request.onsuccess = function() {
      resolve(request.result);
    };
    request.onerror = function() {
      reject(request.error);
    };
  });
}
function promisifyRequestCall(obj, method, args) {
  var request;
  var p = new Promise(function(resolve, reject) {
    request = obj[method].apply(obj, args);
    promisifyRequest(request).then(resolve, reject);
  });
  p.request = request;
  return p;
}
function promisifyCursorRequestCall(obj, method, args) {
  var p = promisifyRequestCall(obj, method, args);
  return p.then(function(value) {
    if (!value)
      return;
    return new Cursor(value, p.request);
  });
}
function proxyProperties(ProxyClass, targetProp, properties) {
  properties.forEach(function(prop) {
    Object.defineProperty(ProxyClass.prototype, prop, {
      get: function() {
        return this[targetProp][prop];
      },
      set: function(val) {
        this[targetProp][prop] = val;
      }
    });
  });
}
function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {
  properties.forEach(function(prop) {
    if (!(prop in Constructor.prototype))
      return;
    ProxyClass.prototype[prop] = function() {
      return promisifyRequestCall(this[targetProp], prop, arguments);
    };
  });
}
function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
  properties.forEach(function(prop) {
    if (!(prop in Constructor.prototype))
      return;
    ProxyClass.prototype[prop] = function() {
      return this[targetProp][prop].apply(this[targetProp], arguments);
    };
  });
}
function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {
  properties.forEach(function(prop) {
    if (!(prop in Constructor.prototype))
      return;
    ProxyClass.prototype[prop] = function() {
      return promisifyCursorRequestCall(this[targetProp], prop, arguments);
    };
  });
}
function Index(index) {
  this._index = index;
}
proxyProperties(Index, "_index", [
  "name",
  "keyPath",
  "multiEntry",
  "unique"
]);
proxyRequestMethods(Index, "_index", IDBIndex, [
  "get",
  "getKey",
  "getAll",
  "getAllKeys",
  "count"
]);
proxyCursorRequestMethods(Index, "_index", IDBIndex, [
  "openCursor",
  "openKeyCursor"
]);
function Cursor(cursor, request) {
  this._cursor = cursor;
  this._request = request;
}
proxyProperties(Cursor, "_cursor", [
  "direction",
  "key",
  "primaryKey",
  "value"
]);
proxyRequestMethods(Cursor, "_cursor", IDBCursor, [
  "update",
  "delete"
]);
["advance", "continue", "continuePrimaryKey"].forEach(function(methodName) {
  if (!(methodName in IDBCursor.prototype))
    return;
  Cursor.prototype[methodName] = function() {
    var cursor = this;
    var args = arguments;
    return Promise.resolve().then(function() {
      cursor._cursor[methodName].apply(cursor._cursor, args);
      return promisifyRequest(cursor._request).then(function(value) {
        if (!value)
          return;
        return new Cursor(value, cursor._request);
      });
    });
  };
});
function ObjectStore(store) {
  this._store = store;
}
ObjectStore.prototype.createIndex = function() {
  return new Index(this._store.createIndex.apply(this._store, arguments));
};
ObjectStore.prototype.index = function() {
  return new Index(this._store.index.apply(this._store, arguments));
};
proxyProperties(ObjectStore, "_store", [
  "name",
  "keyPath",
  "indexNames",
  "autoIncrement"
]);
proxyRequestMethods(ObjectStore, "_store", IDBObjectStore, [
  "put",
  "add",
  "delete",
  "clear",
  "get",
  "getAll",
  "getKey",
  "getAllKeys",
  "count"
]);
proxyCursorRequestMethods(ObjectStore, "_store", IDBObjectStore, [
  "openCursor",
  "openKeyCursor"
]);
proxyMethods(ObjectStore, "_store", IDBObjectStore, [
  "deleteIndex"
]);
function Transaction(idbTransaction) {
  this._tx = idbTransaction;
  this.complete = new Promise(function(resolve, reject) {
    idbTransaction.oncomplete = function() {
      resolve();
    };
    idbTransaction.onerror = function() {
      reject(idbTransaction.error);
    };
    idbTransaction.onabort = function() {
      reject(idbTransaction.error);
    };
  });
}
Transaction.prototype.objectStore = function() {
  return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));
};
proxyProperties(Transaction, "_tx", [
  "objectStoreNames",
  "mode"
]);
proxyMethods(Transaction, "_tx", IDBTransaction, [
  "abort"
]);
function UpgradeDB(db, oldVersion, transaction) {
  this._db = db;
  this.oldVersion = oldVersion;
  this.transaction = new Transaction(transaction);
}
UpgradeDB.prototype.createObjectStore = function() {
  return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));
};
proxyProperties(UpgradeDB, "_db", [
  "name",
  "version",
  "objectStoreNames"
]);
proxyMethods(UpgradeDB, "_db", IDBDatabase, [
  "deleteObjectStore",
  "close"
]);
function DB(db) {
  this._db = db;
}
DB.prototype.transaction = function() {
  return new Transaction(this._db.transaction.apply(this._db, arguments));
};
proxyProperties(DB, "_db", [
  "name",
  "version",
  "objectStoreNames"
]);
proxyMethods(DB, "_db", IDBDatabase, [
  "close"
]);
["openCursor", "openKeyCursor"].forEach(function(funcName) {
  [ObjectStore, Index].forEach(function(Constructor) {
    if (!(funcName in Constructor.prototype))
      return;
    Constructor.prototype[funcName.replace("open", "iterate")] = function() {
      var args = toArray(arguments);
      var callback = args[args.length - 1];
      var nativeObject = this._store || this._index;
      var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));
      request.onsuccess = function() {
        callback(request.result);
      };
    };
  });
});
[Index, ObjectStore].forEach(function(Constructor) {
  if (Constructor.prototype.getAll)
    return;
  Constructor.prototype.getAll = function(query, count) {
    var instance = this;
    var items = [];
    return new Promise(function(resolve) {
      instance.iterateCursor(query, function(cursor) {
        if (!cursor) {
          resolve(items);
          return;
        }
        items.push(cursor.value);
        if (count !== void 0 && items.length == count) {
          resolve(items);
          return;
        }
        cursor.continue();
      });
    });
  };
});
function openDb(name3, version3, upgradeCallback) {
  var p = promisifyRequestCall(indexedDB, "open", [name3, version3]);
  var request = p.request;
  if (request) {
    request.onupgradeneeded = function(event) {
      if (upgradeCallback) {
        upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));
      }
    };
  }
  return p.then(function(db) {
    return new DB(db);
  });
}
function deleteDb(name3) {
  return promisifyRequestCall(indexedDB, "deleteDatabase", [name3]);
}

// node_modules/@firebase/installations/dist/index.esm.js
var name = "@firebase/installations";
var version = "0.4.23";
var PENDING_TIMEOUT_MS = 1e4;
var PACKAGE_VERSION = "w:" + version;
var INTERNAL_AUTH_VERSION = "FIS_v2";
var INSTALLATIONS_API_URL = "https://firebaseinstallations.googleapis.com/v1";
var TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1e3;
var SERVICE = "installations";
var SERVICE_NAME = "Installations";
var _a;
var ERROR_DESCRIPTION_MAP = (_a = {}, _a["missing-app-config-values"] = 'Missing App configuration value: "{$valueName}"', _a["not-registered"] = "Firebase Installation is not registered.", _a["installation-not-found"] = "Firebase Installation not found.", _a["request-failed"] = '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"', _a["app-offline"] = "Could not process request. Application offline.", _a["delete-pending-registration"] = "Can't delete installation while there is a pending registration request.", _a);
var ERROR_FACTORY = new ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);
function isServerError(error) {
  return error instanceof FirebaseError && error.code.includes("request-failed");
}
function getInstallationsEndpoint(_a3) {
  var projectId = _a3.projectId;
  return INSTALLATIONS_API_URL + "/projects/" + projectId + "/installations";
}
function extractAuthTokenInfoFromResponse(response) {
  return {
    token: response.token,
    requestStatus: 2,
    expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),
    creationTime: Date.now()
  };
}
function getErrorFromResponse(requestName, response) {
  return __awaiter(this, void 0, void 0, function() {
    var responseJson, errorData;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, response.json()];
        case 1:
          responseJson = _a3.sent();
          errorData = responseJson.error;
          return [2, ERROR_FACTORY.create("request-failed", {
            requestName,
            serverCode: errorData.code,
            serverMessage: errorData.message,
            serverStatus: errorData.status
          })];
      }
    });
  });
}
function getHeaders(_a3) {
  var apiKey = _a3.apiKey;
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": apiKey
  });
}
function getHeadersWithAuth(appConfig, _a3) {
  var refreshToken = _a3.refreshToken;
  var headers = getHeaders(appConfig);
  headers.append("Authorization", getAuthorizationHeader(refreshToken));
  return headers;
}
function retryIfServerError(fn) {
  return __awaiter(this, void 0, void 0, function() {
    var result;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, fn()];
        case 1:
          result = _a3.sent();
          if (result.status >= 500 && result.status < 600) {
            return [2, fn()];
          }
          return [2, result];
      }
    });
  });
}
function getExpiresInFromResponseExpiresIn(responseExpiresIn) {
  return Number(responseExpiresIn.replace("s", "000"));
}
function getAuthorizationHeader(refreshToken) {
  return INTERNAL_AUTH_VERSION + " " + refreshToken;
}
function createInstallationRequest(appConfig, _a3) {
  var fid = _a3.fid;
  return __awaiter(this, void 0, void 0, function() {
    var endpoint, headers, body, request, response, responseValue, registeredInstallationEntry;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          endpoint = getInstallationsEndpoint(appConfig);
          headers = getHeaders(appConfig);
          body = {
            fid,
            authVersion: INTERNAL_AUTH_VERSION,
            appId: appConfig.appId,
            sdkVersion: PACKAGE_VERSION
          };
          request = {
            method: "POST",
            headers,
            body: JSON.stringify(body)
          };
          return [4, retryIfServerError(function() {
            return fetch(endpoint, request);
          })];
        case 1:
          response = _b.sent();
          if (!response.ok)
            return [3, 3];
          return [4, response.json()];
        case 2:
          responseValue = _b.sent();
          registeredInstallationEntry = {
            fid: responseValue.fid || fid,
            registrationStatus: 2,
            refreshToken: responseValue.refreshToken,
            authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)
          };
          return [2, registeredInstallationEntry];
        case 3:
          return [4, getErrorFromResponse("Create Installation", response)];
        case 4:
          throw _b.sent();
      }
    });
  });
}
function sleep(ms) {
  return new Promise(function(resolve) {
    setTimeout(resolve, ms);
  });
}
function bufferToBase64UrlSafe(array) {
  var b64 = btoa(String.fromCharCode.apply(String, __spreadArray([], __read(array))));
  return b64.replace(/\+/g, "-").replace(/\//g, "_");
}
var VALID_FID_PATTERN = /^[cdef][\w-]{21}$/;
var INVALID_FID = "";
function generateFid() {
  try {
    var fidByteArray = new Uint8Array(17);
    var crypto_1 = self.crypto || self.msCrypto;
    crypto_1.getRandomValues(fidByteArray);
    fidByteArray[0] = 112 + fidByteArray[0] % 16;
    var fid = encode(fidByteArray);
    return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;
  } catch (_a3) {
    return INVALID_FID;
  }
}
function encode(fidByteArray) {
  var b64String = bufferToBase64UrlSafe(fidByteArray);
  return b64String.substr(0, 22);
}
function getKey(appConfig) {
  return appConfig.appName + "!" + appConfig.appId;
}
var fidChangeCallbacks = /* @__PURE__ */ new Map();
function fidChanged(appConfig, fid) {
  var key = getKey(appConfig);
  callFidChangeCallbacks(key, fid);
  broadcastFidChange(key, fid);
}
function addCallback(appConfig, callback) {
  getBroadcastChannel();
  var key = getKey(appConfig);
  var callbackSet = fidChangeCallbacks.get(key);
  if (!callbackSet) {
    callbackSet = /* @__PURE__ */ new Set();
    fidChangeCallbacks.set(key, callbackSet);
  }
  callbackSet.add(callback);
}
function removeCallback(appConfig, callback) {
  var key = getKey(appConfig);
  var callbackSet = fidChangeCallbacks.get(key);
  if (!callbackSet) {
    return;
  }
  callbackSet.delete(callback);
  if (callbackSet.size === 0) {
    fidChangeCallbacks.delete(key);
  }
  closeBroadcastChannel();
}
function callFidChangeCallbacks(key, fid) {
  var e_1, _a3;
  var callbacks = fidChangeCallbacks.get(key);
  if (!callbacks) {
    return;
  }
  try {
    for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
      var callback = callbacks_1_1.value;
      callback(fid);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (callbacks_1_1 && !callbacks_1_1.done && (_a3 = callbacks_1.return))
        _a3.call(callbacks_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
}
function broadcastFidChange(key, fid) {
  var channel = getBroadcastChannel();
  if (channel) {
    channel.postMessage({ key, fid });
  }
  closeBroadcastChannel();
}
var broadcastChannel = null;
function getBroadcastChannel() {
  if (!broadcastChannel && "BroadcastChannel" in self) {
    broadcastChannel = new BroadcastChannel("[Firebase] FID Change");
    broadcastChannel.onmessage = function(e) {
      callFidChangeCallbacks(e.data.key, e.data.fid);
    };
  }
  return broadcastChannel;
}
function closeBroadcastChannel() {
  if (fidChangeCallbacks.size === 0 && broadcastChannel) {
    broadcastChannel.close();
    broadcastChannel = null;
  }
}
var DATABASE_NAME = "firebase-installations-database";
var DATABASE_VERSION = 1;
var OBJECT_STORE_NAME = "firebase-installations-store";
var dbPromise = null;
function getDbPromise() {
  if (!dbPromise) {
    dbPromise = openDb(DATABASE_NAME, DATABASE_VERSION, function(upgradeDB) {
      switch (upgradeDB.oldVersion) {
        case 0:
          upgradeDB.createObjectStore(OBJECT_STORE_NAME);
      }
    });
  }
  return dbPromise;
}
function set(appConfig, value) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db, tx, objectStore, oldValue;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          key = getKey(appConfig);
          return [4, getDbPromise()];
        case 1:
          db = _a3.sent();
          tx = db.transaction(OBJECT_STORE_NAME, "readwrite");
          objectStore = tx.objectStore(OBJECT_STORE_NAME);
          return [4, objectStore.get(key)];
        case 2:
          oldValue = _a3.sent();
          return [4, objectStore.put(value, key)];
        case 3:
          _a3.sent();
          return [4, tx.complete];
        case 4:
          _a3.sent();
          if (!oldValue || oldValue.fid !== value.fid) {
            fidChanged(appConfig, value.fid);
          }
          return [2, value];
      }
    });
  });
}
function remove(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db, tx;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          key = getKey(appConfig);
          return [4, getDbPromise()];
        case 1:
          db = _a3.sent();
          tx = db.transaction(OBJECT_STORE_NAME, "readwrite");
          return [4, tx.objectStore(OBJECT_STORE_NAME).delete(key)];
        case 2:
          _a3.sent();
          return [4, tx.complete];
        case 3:
          _a3.sent();
          return [2];
      }
    });
  });
}
function update(appConfig, updateFn) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db, tx, store, oldValue, newValue;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          key = getKey(appConfig);
          return [4, getDbPromise()];
        case 1:
          db = _a3.sent();
          tx = db.transaction(OBJECT_STORE_NAME, "readwrite");
          store = tx.objectStore(OBJECT_STORE_NAME);
          return [4, store.get(key)];
        case 2:
          oldValue = _a3.sent();
          newValue = updateFn(oldValue);
          if (!(newValue === void 0))
            return [3, 4];
          return [4, store.delete(key)];
        case 3:
          _a3.sent();
          return [3, 6];
        case 4:
          return [4, store.put(newValue, key)];
        case 5:
          _a3.sent();
          _a3.label = 6;
        case 6:
          return [4, tx.complete];
        case 7:
          _a3.sent();
          if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {
            fidChanged(appConfig, newValue.fid);
          }
          return [2, newValue];
      }
    });
  });
}
function getInstallationEntry(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var registrationPromise, installationEntry;
    var _a3;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, update(appConfig, function(oldEntry) {
            var installationEntry2 = updateOrCreateInstallationEntry(oldEntry);
            var entryWithPromise = triggerRegistrationIfNecessary(appConfig, installationEntry2);
            registrationPromise = entryWithPromise.registrationPromise;
            return entryWithPromise.installationEntry;
          })];
        case 1:
          installationEntry = _b.sent();
          if (!(installationEntry.fid === INVALID_FID))
            return [3, 3];
          _a3 = {};
          return [4, registrationPromise];
        case 2:
          return [2, (_a3.installationEntry = _b.sent(), _a3)];
        case 3:
          return [2, {
            installationEntry,
            registrationPromise
          }];
      }
    });
  });
}
function updateOrCreateInstallationEntry(oldEntry) {
  var entry = oldEntry || {
    fid: generateFid(),
    registrationStatus: 0
  };
  return clearTimedOutRequest(entry);
}
function triggerRegistrationIfNecessary(appConfig, installationEntry) {
  if (installationEntry.registrationStatus === 0) {
    if (!navigator.onLine) {
      var registrationPromiseWithError = Promise.reject(ERROR_FACTORY.create("app-offline"));
      return {
        installationEntry,
        registrationPromise: registrationPromiseWithError
      };
    }
    var inProgressEntry = {
      fid: installationEntry.fid,
      registrationStatus: 1,
      registrationTime: Date.now()
    };
    var registrationPromise = registerInstallation(appConfig, inProgressEntry);
    return { installationEntry: inProgressEntry, registrationPromise };
  } else if (installationEntry.registrationStatus === 1) {
    return {
      installationEntry,
      registrationPromise: waitUntilFidRegistration(appConfig)
    };
  } else {
    return { installationEntry };
  }
}
function registerInstallation(appConfig, installationEntry) {
  return __awaiter(this, void 0, void 0, function() {
    var registeredInstallationEntry, e_1;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          _a3.trys.push([0, 2, , 7]);
          return [4, createInstallationRequest(appConfig, installationEntry)];
        case 1:
          registeredInstallationEntry = _a3.sent();
          return [2, set(appConfig, registeredInstallationEntry)];
        case 2:
          e_1 = _a3.sent();
          if (!(isServerError(e_1) && e_1.customData.serverCode === 409))
            return [3, 4];
          return [4, remove(appConfig)];
        case 3:
          _a3.sent();
          return [3, 6];
        case 4:
          return [4, set(appConfig, {
            fid: installationEntry.fid,
            registrationStatus: 0
          })];
        case 5:
          _a3.sent();
          _a3.label = 6;
        case 6:
          throw e_1;
        case 7:
          return [2];
      }
    });
  });
}
function waitUntilFidRegistration(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var entry, _a3, installationEntry, registrationPromise;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, updateInstallationRequest(appConfig)];
        case 1:
          entry = _b.sent();
          _b.label = 2;
        case 2:
          if (!(entry.registrationStatus === 1))
            return [3, 5];
          return [4, sleep(100)];
        case 3:
          _b.sent();
          return [4, updateInstallationRequest(appConfig)];
        case 4:
          entry = _b.sent();
          return [3, 2];
        case 5:
          if (!(entry.registrationStatus === 0))
            return [3, 7];
          return [4, getInstallationEntry(appConfig)];
        case 6:
          _a3 = _b.sent(), installationEntry = _a3.installationEntry, registrationPromise = _a3.registrationPromise;
          if (registrationPromise) {
            return [2, registrationPromise];
          } else {
            return [2, installationEntry];
          }
        case 7:
          return [2, entry];
      }
    });
  });
}
function updateInstallationRequest(appConfig) {
  return update(appConfig, function(oldEntry) {
    if (!oldEntry) {
      throw ERROR_FACTORY.create("installation-not-found");
    }
    return clearTimedOutRequest(oldEntry);
  });
}
function clearTimedOutRequest(entry) {
  if (hasInstallationRequestTimedOut(entry)) {
    return {
      fid: entry.fid,
      registrationStatus: 0
    };
  }
  return entry;
}
function hasInstallationRequestTimedOut(installationEntry) {
  return installationEntry.registrationStatus === 1 && installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now();
}
function generateAuthTokenRequest(_a3, installationEntry) {
  var appConfig = _a3.appConfig, platformLoggerProvider = _a3.platformLoggerProvider;
  return __awaiter(this, void 0, void 0, function() {
    var endpoint, headers, platformLogger, body, request, response, responseValue, completedAuthToken;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);
          headers = getHeadersWithAuth(appConfig, installationEntry);
          platformLogger = platformLoggerProvider.getImmediate({
            optional: true
          });
          if (platformLogger) {
            headers.append("x-firebase-client", platformLogger.getPlatformInfoString());
          }
          body = {
            installation: {
              sdkVersion: PACKAGE_VERSION
            }
          };
          request = {
            method: "POST",
            headers,
            body: JSON.stringify(body)
          };
          return [4, retryIfServerError(function() {
            return fetch(endpoint, request);
          })];
        case 1:
          response = _b.sent();
          if (!response.ok)
            return [3, 3];
          return [4, response.json()];
        case 2:
          responseValue = _b.sent();
          completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);
          return [2, completedAuthToken];
        case 3:
          return [4, getErrorFromResponse("Generate Auth Token", response)];
        case 4:
          throw _b.sent();
      }
    });
  });
}
function getGenerateAuthTokenEndpoint(appConfig, _a3) {
  var fid = _a3.fid;
  return getInstallationsEndpoint(appConfig) + "/" + fid + "/authTokens:generate";
}
function refreshAuthToken(dependencies, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var tokenPromise, entry, authToken, _a3;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, update(dependencies.appConfig, function(oldEntry) {
            if (!isEntryRegistered(oldEntry)) {
              throw ERROR_FACTORY.create("not-registered");
            }
            var oldAuthToken = oldEntry.authToken;
            if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {
              return oldEntry;
            } else if (oldAuthToken.requestStatus === 1) {
              tokenPromise = waitUntilAuthTokenRequest(dependencies, forceRefresh);
              return oldEntry;
            } else {
              if (!navigator.onLine) {
                throw ERROR_FACTORY.create("app-offline");
              }
              var inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);
              tokenPromise = fetchAuthTokenFromServer(dependencies, inProgressEntry);
              return inProgressEntry;
            }
          })];
        case 1:
          entry = _b.sent();
          if (!tokenPromise)
            return [3, 3];
          return [4, tokenPromise];
        case 2:
          _a3 = _b.sent();
          return [3, 4];
        case 3:
          _a3 = entry.authToken;
          _b.label = 4;
        case 4:
          authToken = _a3;
          return [2, authToken];
      }
    });
  });
}
function waitUntilAuthTokenRequest(dependencies, forceRefresh) {
  return __awaiter(this, void 0, void 0, function() {
    var entry, authToken;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, updateAuthTokenRequest(dependencies.appConfig)];
        case 1:
          entry = _a3.sent();
          _a3.label = 2;
        case 2:
          if (!(entry.authToken.requestStatus === 1))
            return [3, 5];
          return [4, sleep(100)];
        case 3:
          _a3.sent();
          return [4, updateAuthTokenRequest(dependencies.appConfig)];
        case 4:
          entry = _a3.sent();
          return [3, 2];
        case 5:
          authToken = entry.authToken;
          if (authToken.requestStatus === 0) {
            return [2, refreshAuthToken(dependencies, forceRefresh)];
          } else {
            return [2, authToken];
          }
      }
    });
  });
}
function updateAuthTokenRequest(appConfig) {
  return update(appConfig, function(oldEntry) {
    if (!isEntryRegistered(oldEntry)) {
      throw ERROR_FACTORY.create("not-registered");
    }
    var oldAuthToken = oldEntry.authToken;
    if (hasAuthTokenRequestTimedOut(oldAuthToken)) {
      return __assign(__assign({}, oldEntry), { authToken: { requestStatus: 0 } });
    }
    return oldEntry;
  });
}
function fetchAuthTokenFromServer(dependencies, installationEntry) {
  return __awaiter(this, void 0, void 0, function() {
    var authToken, updatedInstallationEntry, e_1, updatedInstallationEntry;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          _a3.trys.push([0, 3, , 8]);
          return [4, generateAuthTokenRequest(dependencies, installationEntry)];
        case 1:
          authToken = _a3.sent();
          updatedInstallationEntry = __assign(__assign({}, installationEntry), { authToken });
          return [4, set(dependencies.appConfig, updatedInstallationEntry)];
        case 2:
          _a3.sent();
          return [2, authToken];
        case 3:
          e_1 = _a3.sent();
          if (!(isServerError(e_1) && (e_1.customData.serverCode === 401 || e_1.customData.serverCode === 404)))
            return [3, 5];
          return [4, remove(dependencies.appConfig)];
        case 4:
          _a3.sent();
          return [3, 7];
        case 5:
          updatedInstallationEntry = __assign(__assign({}, installationEntry), { authToken: { requestStatus: 0 } });
          return [4, set(dependencies.appConfig, updatedInstallationEntry)];
        case 6:
          _a3.sent();
          _a3.label = 7;
        case 7:
          throw e_1;
        case 8:
          return [2];
      }
    });
  });
}
function isEntryRegistered(installationEntry) {
  return installationEntry !== void 0 && installationEntry.registrationStatus === 2;
}
function isAuthTokenValid(authToken) {
  return authToken.requestStatus === 2 && !isAuthTokenExpired(authToken);
}
function isAuthTokenExpired(authToken) {
  var now = Date.now();
  return now < authToken.creationTime || authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER;
}
function makeAuthTokenRequestInProgressEntry(oldEntry) {
  var inProgressAuthToken = {
    requestStatus: 1,
    requestTime: Date.now()
  };
  return __assign(__assign({}, oldEntry), { authToken: inProgressAuthToken });
}
function hasAuthTokenRequestTimedOut(authToken) {
  return authToken.requestStatus === 1 && authToken.requestTime + PENDING_TIMEOUT_MS < Date.now();
}
function getId(dependencies) {
  return __awaiter(this, void 0, void 0, function() {
    var _a3, installationEntry, registrationPromise;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, getInstallationEntry(dependencies.appConfig)];
        case 1:
          _a3 = _b.sent(), installationEntry = _a3.installationEntry, registrationPromise = _a3.registrationPromise;
          if (registrationPromise) {
            registrationPromise.catch(console.error);
          } else {
            refreshAuthToken(dependencies).catch(console.error);
          }
          return [2, installationEntry.fid];
      }
    });
  });
}
function getToken(dependencies, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var authToken;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, completeInstallationRegistration(dependencies.appConfig)];
        case 1:
          _a3.sent();
          return [4, refreshAuthToken(dependencies, forceRefresh)];
        case 2:
          authToken = _a3.sent();
          return [2, authToken.token];
      }
    });
  });
}
function completeInstallationRegistration(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var registrationPromise;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, getInstallationEntry(appConfig)];
        case 1:
          registrationPromise = _a3.sent().registrationPromise;
          if (!registrationPromise)
            return [3, 3];
          return [4, registrationPromise];
        case 2:
          _a3.sent();
          _a3.label = 3;
        case 3:
          return [2];
      }
    });
  });
}
function deleteInstallationRequest(appConfig, installationEntry) {
  return __awaiter(this, void 0, void 0, function() {
    var endpoint, headers, request, response;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          endpoint = getDeleteEndpoint(appConfig, installationEntry);
          headers = getHeadersWithAuth(appConfig, installationEntry);
          request = {
            method: "DELETE",
            headers
          };
          return [4, retryIfServerError(function() {
            return fetch(endpoint, request);
          })];
        case 1:
          response = _a3.sent();
          if (!!response.ok)
            return [3, 3];
          return [4, getErrorFromResponse("Delete Installation", response)];
        case 2:
          throw _a3.sent();
        case 3:
          return [2];
      }
    });
  });
}
function getDeleteEndpoint(appConfig, _a3) {
  var fid = _a3.fid;
  return getInstallationsEndpoint(appConfig) + "/" + fid;
}
function deleteInstallation(dependencies) {
  return __awaiter(this, void 0, void 0, function() {
    var appConfig, entry;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          appConfig = dependencies.appConfig;
          return [4, update(appConfig, function(oldEntry) {
            if (oldEntry && oldEntry.registrationStatus === 0) {
              return void 0;
            }
            return oldEntry;
          })];
        case 1:
          entry = _a3.sent();
          if (!entry)
            return [3, 6];
          if (!(entry.registrationStatus === 1))
            return [3, 2];
          throw ERROR_FACTORY.create("delete-pending-registration");
        case 2:
          if (!(entry.registrationStatus === 2))
            return [3, 6];
          if (!!navigator.onLine)
            return [3, 3];
          throw ERROR_FACTORY.create("app-offline");
        case 3:
          return [4, deleteInstallationRequest(appConfig, entry)];
        case 4:
          _a3.sent();
          return [4, remove(appConfig)];
        case 5:
          _a3.sent();
          _a3.label = 6;
        case 6:
          return [2];
      }
    });
  });
}
function onIdChange(_a3, callback) {
  var appConfig = _a3.appConfig;
  addCallback(appConfig, callback);
  return function() {
    removeCallback(appConfig, callback);
  };
}
function extractAppConfig(app) {
  var e_1, _a3;
  if (!app || !app.options) {
    throw getMissingValueError("App Configuration");
  }
  if (!app.name) {
    throw getMissingValueError("App Name");
  }
  var configKeys = [
    "projectId",
    "apiKey",
    "appId"
  ];
  try {
    for (var configKeys_1 = __values(configKeys), configKeys_1_1 = configKeys_1.next(); !configKeys_1_1.done; configKeys_1_1 = configKeys_1.next()) {
      var keyName = configKeys_1_1.value;
      if (!app.options[keyName]) {
        throw getMissingValueError(keyName);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (configKeys_1_1 && !configKeys_1_1.done && (_a3 = configKeys_1.return))
        _a3.call(configKeys_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return {
    appName: app.name,
    projectId: app.options.projectId,
    apiKey: app.options.apiKey,
    appId: app.options.appId
  };
}
function getMissingValueError(valueName) {
  return ERROR_FACTORY.create("missing-app-config-values", {
    valueName
  });
}
function registerInstallations(instance) {
  var installationsName = "installations";
  instance.INTERNAL.registerComponent(new Component(installationsName, function(container) {
    var app = container.getProvider("app").getImmediate();
    var appConfig = extractAppConfig(app);
    var platformLoggerProvider = container.getProvider("platform-logger");
    var dependencies = {
      appConfig,
      platformLoggerProvider
    };
    var installations = {
      app,
      getId: function() {
        return getId(dependencies);
      },
      getToken: function(forceRefresh) {
        return getToken(dependencies, forceRefresh);
      },
      delete: function() {
        return deleteInstallation(dependencies);
      },
      onIdChange: function(callback) {
        return onIdChange(dependencies, callback);
      }
    };
    return installations;
  }, "PUBLIC"));
  instance.registerVersion(name, version);
}
registerInstallations(index_esm_default);

// node_modules/@firebase/analytics/dist/index.esm.js
var GA_FID_KEY = "firebase_id";
var ORIGIN_KEY = "origin";
var FETCH_TIMEOUT_MILLIS = 60 * 1e3;
var DYNAMIC_CONFIG_URL = "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig";
var GTAG_URL = "https://www.googletagmanager.com/gtag/js";
var GtagCommand;
(function(GtagCommand2) {
  GtagCommand2["EVENT"] = "event";
  GtagCommand2["SET"] = "set";
  GtagCommand2["CONFIG"] = "config";
})(GtagCommand || (GtagCommand = {}));
var EventName;
(function(EventName2) {
  EventName2["ADD_SHIPPING_INFO"] = "add_shipping_info";
  EventName2["ADD_PAYMENT_INFO"] = "add_payment_info";
  EventName2["ADD_TO_CART"] = "add_to_cart";
  EventName2["ADD_TO_WISHLIST"] = "add_to_wishlist";
  EventName2["BEGIN_CHECKOUT"] = "begin_checkout";
  EventName2["CHECKOUT_PROGRESS"] = "checkout_progress";
  EventName2["EXCEPTION"] = "exception";
  EventName2["GENERATE_LEAD"] = "generate_lead";
  EventName2["LOGIN"] = "login";
  EventName2["PAGE_VIEW"] = "page_view";
  EventName2["PURCHASE"] = "purchase";
  EventName2["REFUND"] = "refund";
  EventName2["REMOVE_FROM_CART"] = "remove_from_cart";
  EventName2["SCREEN_VIEW"] = "screen_view";
  EventName2["SEARCH"] = "search";
  EventName2["SELECT_CONTENT"] = "select_content";
  EventName2["SELECT_ITEM"] = "select_item";
  EventName2["SELECT_PROMOTION"] = "select_promotion";
  EventName2["SET_CHECKOUT_OPTION"] = "set_checkout_option";
  EventName2["SHARE"] = "share";
  EventName2["SIGN_UP"] = "sign_up";
  EventName2["TIMING_COMPLETE"] = "timing_complete";
  EventName2["VIEW_CART"] = "view_cart";
  EventName2["VIEW_ITEM"] = "view_item";
  EventName2["VIEW_ITEM_LIST"] = "view_item_list";
  EventName2["VIEW_PROMOTION"] = "view_promotion";
  EventName2["VIEW_SEARCH_RESULTS"] = "view_search_results";
})(EventName || (EventName = {}));
function logEvent(gtagFunction, initializationPromise, eventName, eventParams, options) {
  return __awaiter(this, void 0, void 0, function() {
    var measurementId, params;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          if (!(options && options.global))
            return [3, 1];
          gtagFunction(GtagCommand.EVENT, eventName, eventParams);
          return [2];
        case 1:
          return [4, initializationPromise];
        case 2:
          measurementId = _a3.sent();
          params = __assign(__assign({}, eventParams), { "send_to": measurementId });
          gtagFunction(GtagCommand.EVENT, eventName, params);
          _a3.label = 3;
        case 3:
          return [2];
      }
    });
  });
}
function setCurrentScreen(gtagFunction, initializationPromise, screenName, options) {
  return __awaiter(this, void 0, void 0, function() {
    var measurementId;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          if (!(options && options.global))
            return [3, 1];
          gtagFunction(GtagCommand.SET, { "screen_name": screenName });
          return [2, Promise.resolve()];
        case 1:
          return [4, initializationPromise];
        case 2:
          measurementId = _a3.sent();
          gtagFunction(GtagCommand.CONFIG, measurementId, {
            update: true,
            "screen_name": screenName
          });
          _a3.label = 3;
        case 3:
          return [2];
      }
    });
  });
}
function setUserId(gtagFunction, initializationPromise, id, options) {
  return __awaiter(this, void 0, void 0, function() {
    var measurementId;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          if (!(options && options.global))
            return [3, 1];
          gtagFunction(GtagCommand.SET, { "user_id": id });
          return [2, Promise.resolve()];
        case 1:
          return [4, initializationPromise];
        case 2:
          measurementId = _a3.sent();
          gtagFunction(GtagCommand.CONFIG, measurementId, {
            update: true,
            "user_id": id
          });
          _a3.label = 3;
        case 3:
          return [2];
      }
    });
  });
}
function setUserProperties(gtagFunction, initializationPromise, properties, options) {
  return __awaiter(this, void 0, void 0, function() {
    var flatProperties, _i, _a3, key, measurementId;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          if (!(options && options.global))
            return [3, 1];
          flatProperties = {};
          for (_i = 0, _a3 = Object.keys(properties); _i < _a3.length; _i++) {
            key = _a3[_i];
            flatProperties["user_properties." + key] = properties[key];
          }
          gtagFunction(GtagCommand.SET, flatProperties);
          return [2, Promise.resolve()];
        case 1:
          return [4, initializationPromise];
        case 2:
          measurementId = _b.sent();
          gtagFunction(GtagCommand.CONFIG, measurementId, {
            update: true,
            "user_properties": properties
          });
          _b.label = 3;
        case 3:
          return [2];
      }
    });
  });
}
function setAnalyticsCollectionEnabled(initializationPromise, enabled) {
  return __awaiter(this, void 0, void 0, function() {
    var measurementId;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          return [4, initializationPromise];
        case 1:
          measurementId = _a3.sent();
          window["ga-disable-" + measurementId] = !enabled;
          return [2];
      }
    });
  });
}
var logger = new Logger("@firebase/analytics");
function insertScriptTag(dataLayerName2, measurementId) {
  var script = document.createElement("script");
  script.src = GTAG_URL + "?l=" + dataLayerName2 + "&id=" + measurementId;
  script.async = true;
  document.head.appendChild(script);
}
function getOrCreateDataLayer(dataLayerName2) {
  var dataLayer = [];
  if (Array.isArray(window[dataLayerName2])) {
    dataLayer = window[dataLayerName2];
  } else {
    window[dataLayerName2] = dataLayer;
  }
  return dataLayer;
}
function gtagOnConfig(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, measurementId, gtagParams) {
  return __awaiter(this, void 0, void 0, function() {
    var correspondingAppId, dynamicConfigResults, foundConfig, e_1;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          correspondingAppId = measurementIdToAppId2[measurementId];
          _a3.label = 1;
        case 1:
          _a3.trys.push([1, 7, , 8]);
          if (!correspondingAppId)
            return [3, 3];
          return [4, initializationPromisesMap2[correspondingAppId]];
        case 2:
          _a3.sent();
          return [3, 6];
        case 3:
          return [4, Promise.all(dynamicConfigPromisesList2)];
        case 4:
          dynamicConfigResults = _a3.sent();
          foundConfig = dynamicConfigResults.find(function(config) {
            return config.measurementId === measurementId;
          });
          if (!foundConfig)
            return [3, 6];
          return [4, initializationPromisesMap2[foundConfig.appId]];
        case 5:
          _a3.sent();
          _a3.label = 6;
        case 6:
          return [3, 8];
        case 7:
          e_1 = _a3.sent();
          logger.error(e_1);
          return [3, 8];
        case 8:
          gtagCore(GtagCommand.CONFIG, measurementId, gtagParams);
          return [2];
      }
    });
  });
}
function gtagOnEvent(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementId, gtagParams) {
  return __awaiter(this, void 0, void 0, function() {
    var initializationPromisesToWaitFor, gaSendToList, dynamicConfigResults, _loop_1, _i, gaSendToList_1, sendToId, state_1, e_2;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          _a3.trys.push([0, 4, , 5]);
          initializationPromisesToWaitFor = [];
          if (!(gtagParams && gtagParams["send_to"]))
            return [3, 2];
          gaSendToList = gtagParams["send_to"];
          if (!Array.isArray(gaSendToList)) {
            gaSendToList = [gaSendToList];
          }
          return [4, Promise.all(dynamicConfigPromisesList2)];
        case 1:
          dynamicConfigResults = _a3.sent();
          _loop_1 = function(sendToId2) {
            var foundConfig = dynamicConfigResults.find(function(config) {
              return config.measurementId === sendToId2;
            });
            var initializationPromise = foundConfig && initializationPromisesMap2[foundConfig.appId];
            if (initializationPromise) {
              initializationPromisesToWaitFor.push(initializationPromise);
            } else {
              initializationPromisesToWaitFor = [];
              return "break";
            }
          };
          for (_i = 0, gaSendToList_1 = gaSendToList; _i < gaSendToList_1.length; _i++) {
            sendToId = gaSendToList_1[_i];
            state_1 = _loop_1(sendToId);
            if (state_1 === "break")
              break;
          }
          _a3.label = 2;
        case 2:
          if (initializationPromisesToWaitFor.length === 0) {
            initializationPromisesToWaitFor = Object.values(initializationPromisesMap2);
          }
          return [4, Promise.all(initializationPromisesToWaitFor)];
        case 3:
          _a3.sent();
          gtagCore(GtagCommand.EVENT, measurementId, gtagParams || {});
          return [3, 5];
        case 4:
          e_2 = _a3.sent();
          logger.error(e_2);
          return [3, 5];
        case 5:
          return [2];
      }
    });
  });
}
function wrapGtag(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2) {
  function gtagWrapper(command, idOrNameOrParams, gtagParams) {
    return __awaiter(this, void 0, void 0, function() {
      var e_3;
      return __generator(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            _a3.trys.push([0, 6, , 7]);
            if (!(command === GtagCommand.EVENT))
              return [3, 2];
            return [4, gtagOnEvent(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, idOrNameOrParams, gtagParams)];
          case 1:
            _a3.sent();
            return [3, 5];
          case 2:
            if (!(command === GtagCommand.CONFIG))
              return [3, 4];
            return [4, gtagOnConfig(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, idOrNameOrParams, gtagParams)];
          case 3:
            _a3.sent();
            return [3, 5];
          case 4:
            gtagCore(GtagCommand.SET, idOrNameOrParams);
            _a3.label = 5;
          case 5:
            return [3, 7];
          case 6:
            e_3 = _a3.sent();
            logger.error(e_3);
            return [3, 7];
          case 7:
            return [2];
        }
      });
    });
  }
  return gtagWrapper;
}
function wrapOrCreateGtag(initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, dataLayerName2, gtagFunctionName) {
  var gtagCore = function() {
    var _args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      _args[_i] = arguments[_i];
    }
    window[dataLayerName2].push(arguments);
  };
  if (window[gtagFunctionName] && typeof window[gtagFunctionName] === "function") {
    gtagCore = window[gtagFunctionName];
  }
  window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2);
  return {
    gtagCore,
    wrappedGtag: window[gtagFunctionName]
  };
}
function findGtagScriptOnPage() {
  var scriptTags = window.document.getElementsByTagName("script");
  for (var _i = 0, _a3 = Object.values(scriptTags); _i < _a3.length; _i++) {
    var tag = _a3[_i];
    if (tag.src && tag.src.includes(GTAG_URL)) {
      return tag;
    }
  }
  return null;
}
var _a2;
var ERRORS = (_a2 = {}, _a2["already-exists"] = "A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.", _a2["already-initialized"] = "Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.", _a2["interop-component-reg-failed"] = "Firebase Analytics Interop Component failed to instantiate: {$reason}", _a2["invalid-analytics-context"] = "Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}", _a2["indexeddb-unavailable"] = "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}", _a2["fetch-throttle"] = "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.", _a2["config-fetch-failed"] = "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}", _a2["no-api-key"] = 'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.', _a2["no-app-id"] = 'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.', _a2);
var ERROR_FACTORY2 = new ErrorFactory("analytics", "Analytics", ERRORS);
var LONG_RETRY_FACTOR = 30;
var BASE_INTERVAL_MILLIS = 1e3;
var RetryData = function() {
  function RetryData2(throttleMetadata, intervalMillis) {
    if (throttleMetadata === void 0) {
      throttleMetadata = {};
    }
    if (intervalMillis === void 0) {
      intervalMillis = BASE_INTERVAL_MILLIS;
    }
    this.throttleMetadata = throttleMetadata;
    this.intervalMillis = intervalMillis;
  }
  RetryData2.prototype.getThrottleMetadata = function(appId) {
    return this.throttleMetadata[appId];
  };
  RetryData2.prototype.setThrottleMetadata = function(appId, metadata) {
    this.throttleMetadata[appId] = metadata;
  };
  RetryData2.prototype.deleteThrottleMetadata = function(appId) {
    delete this.throttleMetadata[appId];
  };
  return RetryData2;
}();
var defaultRetryData = new RetryData();
function getHeaders2(apiKey) {
  return new Headers({
    Accept: "application/json",
    "x-goog-api-key": apiKey
  });
}
function fetchDynamicConfig(appFields) {
  var _a3;
  return __awaiter(this, void 0, void 0, function() {
    var appId, apiKey, request, appUrl, response, errorMessage, jsonResponse, _ignored_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          appId = appFields.appId, apiKey = appFields.apiKey;
          request = {
            method: "GET",
            headers: getHeaders2(apiKey)
          };
          appUrl = DYNAMIC_CONFIG_URL.replace("{app-id}", appId);
          return [4, fetch(appUrl, request)];
        case 1:
          response = _b.sent();
          if (!(response.status !== 200 && response.status !== 304))
            return [3, 6];
          errorMessage = "";
          _b.label = 2;
        case 2:
          _b.trys.push([2, 4, , 5]);
          return [4, response.json()];
        case 3:
          jsonResponse = _b.sent();
          if ((_a3 = jsonResponse.error) === null || _a3 === void 0 ? void 0 : _a3.message) {
            errorMessage = jsonResponse.error.message;
          }
          return [3, 5];
        case 4:
          _ignored_1 = _b.sent();
          return [3, 5];
        case 5:
          throw ERROR_FACTORY2.create("config-fetch-failed", {
            httpStatus: response.status,
            responseMessage: errorMessage
          });
        case 6:
          return [2, response.json()];
      }
    });
  });
}
function fetchDynamicConfigWithRetry(app, retryData, timeoutMillis) {
  if (retryData === void 0) {
    retryData = defaultRetryData;
  }
  return __awaiter(this, void 0, void 0, function() {
    var _a3, appId, apiKey, measurementId, throttleMetadata, signal;
    var _this = this;
    return __generator(this, function(_b) {
      _a3 = app.options, appId = _a3.appId, apiKey = _a3.apiKey, measurementId = _a3.measurementId;
      if (!appId) {
        throw ERROR_FACTORY2.create("no-app-id");
      }
      if (!apiKey) {
        if (measurementId) {
          return [2, {
            measurementId,
            appId
          }];
        }
        throw ERROR_FACTORY2.create("no-api-key");
      }
      throttleMetadata = retryData.getThrottleMetadata(appId) || {
        backoffCount: 0,
        throttleEndTimeMillis: Date.now()
      };
      signal = new AnalyticsAbortSignal();
      setTimeout(function() {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a4) {
            signal.abort();
            return [2];
          });
        });
      }, timeoutMillis !== void 0 ? timeoutMillis : FETCH_TIMEOUT_MILLIS);
      return [2, attemptFetchDynamicConfigWithRetry({ appId, apiKey, measurementId }, throttleMetadata, signal, retryData)];
    });
  });
}
function attemptFetchDynamicConfigWithRetry(appFields, _a3, signal, retryData) {
  var throttleEndTimeMillis = _a3.throttleEndTimeMillis, backoffCount = _a3.backoffCount;
  if (retryData === void 0) {
    retryData = defaultRetryData;
  }
  return __awaiter(this, void 0, void 0, function() {
    var appId, measurementId, e_1, response, e_2, backoffMillis, throttleMetadata;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          appId = appFields.appId, measurementId = appFields.measurementId;
          _b.label = 1;
        case 1:
          _b.trys.push([1, 3, , 4]);
          return [4, setAbortableTimeout(signal, throttleEndTimeMillis)];
        case 2:
          _b.sent();
          return [3, 4];
        case 3:
          e_1 = _b.sent();
          if (measurementId) {
            logger.warn("Timed out fetching this Firebase app's measurement ID from the server." + (" Falling back to the measurement ID " + measurementId) + (' provided in the "measurementId" field in the local Firebase config. [' + e_1.message + "]"));
            return [2, { appId, measurementId }];
          }
          throw e_1;
        case 4:
          _b.trys.push([4, 6, , 7]);
          return [4, fetchDynamicConfig(appFields)];
        case 5:
          response = _b.sent();
          retryData.deleteThrottleMetadata(appId);
          return [2, response];
        case 6:
          e_2 = _b.sent();
          if (!isRetriableError(e_2)) {
            retryData.deleteThrottleMetadata(appId);
            if (measurementId) {
              logger.warn("Failed to fetch this Firebase app's measurement ID from the server." + (" Falling back to the measurement ID " + measurementId) + (' provided in the "measurementId" field in the local Firebase config. [' + e_2.message + "]"));
              return [2, { appId, measurementId }];
            } else {
              throw e_2;
            }
          }
          backoffMillis = Number(e_2.customData.httpStatus) === 503 ? calculateBackoffMillis(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR) : calculateBackoffMillis(backoffCount, retryData.intervalMillis);
          throttleMetadata = {
            throttleEndTimeMillis: Date.now() + backoffMillis,
            backoffCount: backoffCount + 1
          };
          retryData.setThrottleMetadata(appId, throttleMetadata);
          logger.debug("Calling attemptFetch again in " + backoffMillis + " millis");
          return [2, attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData)];
        case 7:
          return [2];
      }
    });
  });
}
function setAbortableTimeout(signal, throttleEndTimeMillis) {
  return new Promise(function(resolve, reject) {
    var backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);
    var timeout = setTimeout(resolve, backoffMillis);
    signal.addEventListener(function() {
      clearTimeout(timeout);
      reject(ERROR_FACTORY2.create("fetch-throttle", {
        throttleEndTimeMillis
      }));
    });
  });
}
function isRetriableError(e) {
  if (!(e instanceof FirebaseError) || !e.customData) {
    return false;
  }
  var httpStatus = Number(e.customData["httpStatus"]);
  return httpStatus === 429 || httpStatus === 500 || httpStatus === 503 || httpStatus === 504;
}
var AnalyticsAbortSignal = function() {
  function AnalyticsAbortSignal2() {
    this.listeners = [];
  }
  AnalyticsAbortSignal2.prototype.addEventListener = function(listener) {
    this.listeners.push(listener);
  };
  AnalyticsAbortSignal2.prototype.abort = function() {
    this.listeners.forEach(function(listener) {
      return listener();
    });
  };
  return AnalyticsAbortSignal2;
}();
function validateIndexedDB() {
  return __awaiter(this, void 0, void 0, function() {
    var e_1;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          if (!!isIndexedDBAvailable())
            return [3, 1];
          logger.warn(ERROR_FACTORY2.create("indexeddb-unavailable", {
            errorInfo: "IndexedDB is not available in this environment."
          }).message);
          return [2, false];
        case 1:
          _a3.trys.push([1, 3, , 4]);
          return [4, validateIndexedDBOpenable()];
        case 2:
          _a3.sent();
          return [3, 4];
        case 3:
          e_1 = _a3.sent();
          logger.warn(ERROR_FACTORY2.create("indexeddb-unavailable", {
            errorInfo: e_1
          }).message);
          return [2, false];
        case 4:
          return [2, true];
      }
    });
  });
}
function initializeIds(app, dynamicConfigPromisesList2, measurementIdToAppId2, installations, gtagCore, dataLayerName2) {
  return __awaiter(this, void 0, void 0, function() {
    var dynamicConfigPromise, fidPromise, _a3, dynamicConfig, fid, configProperties;
    var _b;
    return __generator(this, function(_c) {
      switch (_c.label) {
        case 0:
          dynamicConfigPromise = fetchDynamicConfigWithRetry(app);
          dynamicConfigPromise.then(function(config) {
            measurementIdToAppId2[config.measurementId] = config.appId;
            if (app.options.measurementId && config.measurementId !== app.options.measurementId) {
              logger.warn("The measurement ID in the local Firebase config (" + app.options.measurementId + ")" + (" does not match the measurement ID fetched from the server (" + config.measurementId + ").") + " To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.");
            }
          }).catch(function(e) {
            return logger.error(e);
          });
          dynamicConfigPromisesList2.push(dynamicConfigPromise);
          fidPromise = validateIndexedDB().then(function(envIsValid) {
            if (envIsValid) {
              return installations.getId();
            } else {
              return void 0;
            }
          });
          return [4, Promise.all([
            dynamicConfigPromise,
            fidPromise
          ])];
        case 1:
          _a3 = _c.sent(), dynamicConfig = _a3[0], fid = _a3[1];
          if (!findGtagScriptOnPage()) {
            insertScriptTag(dataLayerName2, dynamicConfig.measurementId);
          }
          gtagCore("js", new Date());
          configProperties = (_b = {}, _b[ORIGIN_KEY] = "firebase", _b.update = true, _b);
          if (fid != null) {
            configProperties[GA_FID_KEY] = fid;
          }
          gtagCore(GtagCommand.CONFIG, dynamicConfig.measurementId, configProperties);
          return [2, dynamicConfig.measurementId];
      }
    });
  });
}
var initializationPromisesMap = {};
var dynamicConfigPromisesList = [];
var measurementIdToAppId = {};
var dataLayerName = "dataLayer";
var gtagName = "gtag";
var gtagCoreFunction;
var wrappedGtagFunction;
var globalInitDone = false;
function settings(options) {
  if (globalInitDone) {
    throw ERROR_FACTORY2.create("already-initialized");
  }
  if (options.dataLayerName) {
    dataLayerName = options.dataLayerName;
  }
  if (options.gtagName) {
    gtagName = options.gtagName;
  }
}
function warnOnBrowserContextMismatch() {
  var mismatchedEnvMessages = [];
  if (isBrowserExtension()) {
    mismatchedEnvMessages.push("This is a browser extension environment.");
  }
  if (!areCookiesEnabled()) {
    mismatchedEnvMessages.push("Cookies are not available.");
  }
  if (mismatchedEnvMessages.length > 0) {
    var details = mismatchedEnvMessages.map(function(message, index) {
      return "(" + (index + 1) + ") " + message;
    }).join(" ");
    var err = ERROR_FACTORY2.create("invalid-analytics-context", {
      errorInfo: details
    });
    logger.warn(err.message);
  }
}
function factory(app, installations) {
  warnOnBrowserContextMismatch();
  var appId = app.options.appId;
  if (!appId) {
    throw ERROR_FACTORY2.create("no-app-id");
  }
  if (!app.options.apiKey) {
    if (app.options.measurementId) {
      logger.warn('The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest' + (" measurement ID for this Firebase app. Falling back to the measurement ID " + app.options.measurementId) + ' provided in the "measurementId" field in the local Firebase config.');
    } else {
      throw ERROR_FACTORY2.create("no-api-key");
    }
  }
  if (initializationPromisesMap[appId] != null) {
    throw ERROR_FACTORY2.create("already-exists", {
      id: appId
    });
  }
  if (!globalInitDone) {
    getOrCreateDataLayer(dataLayerName);
    var _a3 = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName), wrappedGtag = _a3.wrappedGtag, gtagCore = _a3.gtagCore;
    wrappedGtagFunction = wrappedGtag;
    gtagCoreFunction = gtagCore;
    globalInitDone = true;
  }
  initializationPromisesMap[appId] = initializeIds(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName);
  var analyticsInstance = {
    app,
    logEvent: function(eventName, eventParams, options) {
      logEvent(wrappedGtagFunction, initializationPromisesMap[appId], eventName, eventParams, options).catch(function(e) {
        return logger.error(e);
      });
    },
    setCurrentScreen: function(screenName, options) {
      setCurrentScreen(wrappedGtagFunction, initializationPromisesMap[appId], screenName, options).catch(function(e) {
        return logger.error(e);
      });
    },
    setUserId: function(id, options) {
      setUserId(wrappedGtagFunction, initializationPromisesMap[appId], id, options).catch(function(e) {
        return logger.error(e);
      });
    },
    setUserProperties: function(properties, options) {
      setUserProperties(wrappedGtagFunction, initializationPromisesMap[appId], properties, options).catch(function(e) {
        return logger.error(e);
      });
    },
    setAnalyticsCollectionEnabled: function(enabled) {
      setAnalyticsCollectionEnabled(initializationPromisesMap[appId], enabled).catch(function(e) {
        return logger.error(e);
      });
    },
    INTERNAL: {
      delete: function() {
        delete initializationPromisesMap[appId];
        return Promise.resolve();
      }
    }
  };
  return analyticsInstance;
}
var name2 = "@firebase/analytics";
var version2 = "0.6.7";
var ANALYTICS_TYPE = "analytics";
function registerAnalytics(instance) {
  instance.INTERNAL.registerComponent(new Component(ANALYTICS_TYPE, function(container) {
    var app = container.getProvider("app").getImmediate();
    var installations = container.getProvider("installations").getImmediate();
    return factory(app, installations);
  }, "PUBLIC").setServiceProps({
    settings,
    EventName,
    isSupported
  }));
  instance.INTERNAL.registerComponent(new Component("analytics-internal", internalFactory, "PRIVATE"));
  instance.registerVersion(name2, version2);
  function internalFactory(container) {
    try {
      var analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();
      return {
        logEvent: analytics.logEvent
      };
    } catch (e) {
      throw ERROR_FACTORY2.create("interop-component-reg-failed", {
        reason: e
      });
    }
  }
}
registerAnalytics(index_esm_default);
function isSupported() {
  return __awaiter(this, void 0, void 0, function() {
    var isDBOpenable, error_1;
    return __generator(this, function(_a3) {
      switch (_a3.label) {
        case 0:
          if (isBrowserExtension()) {
            return [2, false];
          }
          if (!areCookiesEnabled()) {
            return [2, false];
          }
          if (!isIndexedDBAvailable()) {
            return [2, false];
          }
          _a3.label = 1;
        case 1:
          _a3.trys.push([1, 3, , 4]);
          return [4, validateIndexedDBOpenable()];
        case 2:
          isDBOpenable = _a3.sent();
          return [2, isDBOpenable];
        case 3:
          error_1 = _a3.sent();
          return [2, false];
        case 4:
          return [2];
      }
    });
  });
}

export {
  openDb,
  deleteDb
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//# sourceMappingURL=chunk-G4QUVS33.js.map
